6.1 转换生成语法

诺姆·乔姆斯基（Noam Chomsky,1928—），当代最著名的语言学家和语言哲学家，创立了转换生成语法理论。这一理论不仅获得了语言学界很高的评价，而且在心理学、哲学、逻辑学等方面引起了人们普遍的重视。1972年诺姆·乔姆斯基当选为国家科学院院士，1984年获美国心理学会颁发的杰出科学贡献奖。

### 6.1.1 乔姆斯基的语言观

乔姆斯基的伟大之处在于他重新确立了人们的“语言”观。

“语言”在生成语法学中被界定为如下。

句子的（有限的或无限的）集（set），每个句子在长度上是有限的，它由结构成分有限的集构成。

——（Chomsky 1957, 《句法结构》）

自然语言中的每一个具体的语种都是无限的句子集合，是在有限的规则基础上生成无限多的句子的集合。其特征如下。

（1）无限性：自然语言是一个无限集，其中的元素是句子。语言是以有限的手段作无限的运用。

（2）离散性：以有限的符号构成无限的符号序列；任何连续的话语都可以切分为更小的片段。

（3）结构层次性：线性特征中蕴涵着层次关系。这一特征是描写主义语言学揭示出来的。

“语法是研究具体语言里用以构造句子的原则和加工过程。”（Chomsky 1957）。一种语言的语法是一种装置，它不仅应该能生成该语言中所有的句子，而且只能生成合格的（Well-Formed）句子。具体语言的语法表现为一套有限的规则系统。这个系统由如下三个子系统构成：句法部分、音系部分和语义部分。

关于语法和语言的关系，转换生成语法给出了如下基本假设。

❑ 天赋观：人们的语言能力是先天就有的，核心语法人无须学习，而其他边缘部分，需要后天学习。

❑ 普遍观：人的语法知识包括两个部分。一部分是全人类特有的，称为普遍语法（Universal Grammar）；另一部分是具体语种所具有的，称为“个别语法”（Particular Grammar）。普遍语法表现为一套有限的原则和数量极少的参数。

❑ 自治观：人们头脑中生来就有专司语言加工的独立机制，句法不用参照意义和其他因素就能对语句从形式上作出系统描述。

❑ 模块观：乔姆斯基假设出一套模块论分析方案，将语言分成音位子模块、句法子模块和语义子模块。

❑ 二元论与形式观：心智中的句法操作可以完全独立于意义而存在，语言中的句法可运用一套纯形式的句法公式来加以演算。因此，某一种语言中的全部合乎语法的句子就是基于一套形式化的符号、通过一定的规则对其进行形式操作而生成出来的。

——《构式语法》

因此，乔姆斯基认为语法是第一性的，而具体的语言则是派生性的，是由在语法基础上构成的无限多的具体句子所构成的集合。

语法可以看作一种“内在性语言”（I-Language），具体的语言则是一种“外在化语言”（E-language）。转换生成语法的研究目标不是描述语言的表层结构，而是揭示语言生成的内在机制。在从某种意义上说，所有的语法都是人类在交流中由大脑生成的，那么语法规则的最终目的就是描写生成句子的这些思维机制。而且，语法规则都是从几条普遍原则转换而来的，因此称为转换生成语法。转换的步骤是有限的，而过程是递归的。

乔姆斯基于1957年后做了几年研究，到1965年便建立起一个完整的生成语法系统，包括语类、转换、音系和语义4个子系统，各子系统之间有一定的顺序关系。每个子系统都有一套规则，规则之间有一定的使用顺序，像用数学公式一样，逐步推导出句子来，不同的规则推导出不同的句子。这样，生成语法系统好比一部机械装置，运转起来能够生成某种语言中的一切合格的句子，而且只能生成那些合格的句子。当然，毋庸置疑，系统在构造和实践中，也出现了很多新的问题，以生成语法系统为基础，乔姆斯基的理论形成了如下5个不同的历史阶段。

❑ 古典理论阶段。

❑ 标准理论时期。

❑ 扩充标注理论时期。

❑ 管辖和约束理论时期。

❑ 最简方案时期。

这些各个历史阶段的具体内容，这里不再赘述，有兴趣的读者可以参考乔姆斯基的相关著作。下面章节着重谈论一下，乔姆斯基的转换生成语法对句法解析的一些重要贡献。

### 6.1.2 短语结构文法

在第三章和第四章的内容中，我们主要做了两件事，将句子的中每个字依照词典和模型归并成词汇，再将这些词汇按照词性和上下文等特征归并为短语（语义组块）。综合来看为两个步骤，其实就是自底向上逐层归纳的过程。

在分析一个句子时，也使用这种思路。将句子中的句法构造层次考虑进来，并按其构造层次，逐层进行分析，在分析时，指出每一层面的直接组成成分：词汇、短语、小句和句子。这种分析方法就是乔姆斯基对语言学最大的贡献，即短语结构文法。

1．短语结构文法

短语结构文法可以形式化定义为G=(X, V, S, R)这样一个四元组。

X是一个有限词汇的集合（词典），它的元素称为词汇或终结符。

V是一个有限标注的集合，叫作非终结符集合，它的元素称为变量或非终结符集合。

S∈V，称为文法的开始符号。

R是有序偶对(α, β)的集合。α是集合(X∪V)上的字符串，但至少包含一个非终结符；β是集合(X∪V)*（这里*表示闭包）的元素。一般的，将有序偶对(α, β)记为α->β，称为产生式。这里“->”读作“定义为”。

注意：第一个产生式的左边只能有一个符号，就是开始符号S。

在自然语言处理中，终结符均为词汇、数字和标点符号。非终结符可以是词性、短语标注、小句标注等符号。

推导的定义：给定文法G, α和β是集合(X∪V)上的字符串，若α、β可以分别写成pvr和pur（p和r可能同时为空串），而v->u是文法G的一个产生式，则称串α可以直接推导出串β。记为：α=>β或pvr=>pur。

实际上所谓“推导”，就是用右侧的串中的u替代左侧的串中的v。

除标准的推导定义之外，同时还定义了如下两个推导符号。

❑ 用符号![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784682477-5ba5fbb0-4a83-443f-a5a9-08bca41ce0ed.jpeg)表示y可以经过任意步（包括0步）推导出z，即

➢ y=z。

➢ 存在一个序列：α1, α2, α3, …, αn，有y=α1, z=αn，且αi=>αi+1，对所有i≥1。

❑ 用符号![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784682836-5d08b1fe-f489-4e9a-9760-33f55b3cb675.jpeg)表示y可以经过多步（最少1步）推导出z，即

存在一个序列：α1, α2, α3, …, αn，有y=α1, z=αn，且αi=>αi+1，对所有i≥1。

下面给出句型和句子的定义。

对于文法G，如果![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784683185-497a64f5-3672-49cb-afce-f05670367618.jpeg)，则称w是文法G的一个句型，若w中包含的字符全是非终结符，则称w是一个句子。

有了句型和句子的定义，自然可以得到语言的定义。所谓语言，在乔姆斯基的短语结构语法中定义如下。

给定文法G，有开始符号S，则把S可以推导出的所有的终结符串的集合（所有的句子集合）称为由文法产生的语言，记为L(G)。

注意：对于文法和语言，可以从一个文法得到该文法产生的语言；也可以根据语言，写出产生该语言的某种文法。在后面讲的PCFG等算法中，从句子产生文法的过程称为训练或学习过程，从文法产生语言的过程称为生成过程。

2．上下文无关文法

乔姆斯基的短语结构文法分为上下文无关文法和上下文有关文法两类。因为两者从本质上差别不大，绝大多数上下文有关文法产生的规则都可以转换为上下文无关文法。这里主要研究上下文无关文法的概念。

定义：给定文法G，如果对于G中的任意产生式v->w，而v只是一个非终结符，即A->w, A∈V, ∈(X∪V)*，则称文法G为上下文无关文法CFG。

下面看一个简单的实例，假设有一个上下文无关文法的产生式。

（1）S-> NP, VP.

（2）VP->VP, AS, NP.

（3）NP->NN.

（4）NP->NR.

（5）NN -> [会议].

（6）NR -> [张三].

（7）VV->[参加] .

（8）AS ->[了] .

另外有一个例句，该句是经过分词、词性标注之后得到的结果，也可以看作事先应用了第（5）～（8）条规则。

张三/NR参加/VV了/AS会议/NN

我们希望对上述例句使用上下文无关文法推导出其层次结构。

推导过程如下。

首先换一下形式，将例句换为宾州树库的表示方法。

(NR张三) (VV参加) (AS了) (NN会议)

按照上述文法产生式（规则），分别应用第（3）条和第（4）条规则。这样就得到如下两个NP。

(NP (NR张三)) (VV参加) (AS了) (NP (NN会议))

再次应用上述文法规则中的第（2）条，也就是说VP要与跟在它后面的体词AS和它的宾语NP结合到一起，形成一个完整的VP，于是上式变为如下内容。

(NP (NR张三)) (VP (VV参加) (AS了) (NP (NN会议)))

最后应用第（1）条规则，设置整个句子的根节点为S（如果自动标注，会选择简单句的标签IP，或ROOT表示为整个句子的根节点），最终结果就写成如下内容。

(S (NP (NR张三)) (VP (VV参加) (AS了) (NP (NN会议))))

这就是我们推导的最终结果，这个结果称为推导树，也称为句法树的数据表示。推导树除具有数据的表示形式还有图形的表示形式，其图形表示就是一棵我们常见的句法树。

推导树（句法树）可以表示为一棵有向无环图。树的根节点是文法的开始符号S（当然也可以是ROOT）。树的其他节点是文法中的非终结符或终结符。

如果推导使用了产生式A->α1, α2, α3, …, αn，其中，A是非终结符，αi可以是终结符或非终结符，则α1, α2, α3, …, αn都是A的直接后继节点，其中A称为父节点，α1, α2, α3, …, αn称为子节点。若节点是终结符，则该节点称为叶子节点。若节点是非终结符，则该节点称为非叶子节点，或直接简称节点。

需要说明的是，推导树不仅可以表示句子的产生，也可以表示一个句型，但句型的叶子节点都是非终结节点。

在推导树中，从根节点到一个叶子节点的边的集合称为一条路径，一条路径上的非终结符的个数称为路径的长度。最大的路径长度就是该推导树的高度。

在一棵推导树T中，以任意一个非终结符A为根，连同它的所有后继节点（直接的节点和非直接的节点），构成一棵子树，称之为推导树T的A-子树。本书中推导树就是树T的最大的一棵子树，即S-子树。

在推导树（句法树）中，一个节点对其所有下位节点构成“支配”（Dominate）关系。支配是一种由上到下的纵向关系。在有支配关系的两个节点中，若没有其他节点出现，这样的支配关系称为“直接支配”（Immediately Dominate）关系。在直接支配关系中，处于支配地位的节点称为父节点。同属一个父节点的两个或两个以上的节点称为兄弟节点。

最后，使用一个NLTK库的程序来显示这棵上述例子中推导树的树状图，如图6.1所示。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784683740-d38411b9-76c5-4139-a418-90baefbae668.jpeg)

图6.1 短语结构推导树

最终生成的推导树，也就是我们常说的句法树，就好像一棵倒置的大树。其中，“IP”称为“根”，一般用“ROOT”来表示，“根”下面每个非终结符出现的位置就是节点，出现在终结符位置的词语串就是叶子节点，连接根和节点、节点和节点、节点和叶子节点之间的线称为“边”，边所代表的含义就是上述8条产生式规则集。其中，根IP有两个分枝，称为二叉分枝（说明产生式的右侧有两项）。一个节点如有三个分枝则称为三叉分枝（说明产生式的右侧有三项）。如图6.1中的VP就分叉为VV、AS、NP三个枝。

图6.1中，ROOT节点不仅支配VP节点和第一个NP节点，也支配其下不同层次上的其他节点。VP及其下位节点为ROOT所支配，但VP只能支配自己的下位节点。直属于ROOT的NP节点或说受ROOT直接支配的NP节点是句子的主语，直属于VP的NP节点或说受VP直接支配的NP节点是句子的宾语。

上下文无关文法的直接结果有如下两个。

（1）句法树数据表示：使用“()”或“[]”作为成分切分符号的嵌套格式的句法树。

（2）句法树图形表示：短语结构图。

下面我们给出实现代码。

NLTK的程序代码也很简单，内容如下。

​        \# -＊- coding: utf-8 -＊-

​        import sys, os

​        import nltk

​        from nltk.corpus import treebank

​        from nltk.tree import Tree

​        reload(sys)

​        sys.setdefaultencoding('utf-8')

​        sentTree = "(IP (NP (NR 张三))  (VP (VV 参加) (AS 了)  (NP (NN会议))))"

​        tree = Tree.fromstring(sentTree)

​        tree.draw()

同时，还给出stanford PCFG Parser的Java运行代码，内容如下。

​        package edu.stanford.nlp.ademo;

​        import java.util.List;

​        import edu.stanford.nlp.ling.CoreLabel;

​        import edu.stanford.nlp.parser.lexparser.LexicalizedParser;

​        import edu.stanford.nlp.ling.Sentence;

​        import edu.stanford.nlp.trees.Tree;

​        public class PCFGDemo {

​            public static void main(String[] args) {

​                LexicalizedParser lp = LexicalizedParser

​                          .loadModel("models/lexparser/chinesePCFG.ser.gz");

​                String[] sent = { "张三", "参加", "了", "会议" };

​                List<CoreLabel> rawWords = Sentence.toCoreLabelList(sent);

​                Tree parse = lp.apply(rawWords);

​                parse.pennPrint(); // 输出的结果类似于语法分析树

​                System.out.println();

​            }

​        }

执行结果如下。

​        (ROOT

​          (IP

​            (NP (NR 张三))

​            (VP (VV 参加) (AS 了)

​              (NP (NN 会议)))))

使用句法树来表示句子的结构不是计算语言学的专利，在语言教育等相关领域，也都用句法树来表示句子的分析结果。句法树也是人类学习语言、分析语言的助手。句法树表示一个句子的层次结构不是偶然，它是直观的句子形式模型描述，无论是人还是机器都很容易理解，便于作为一种统一的句子理解的结果表述。本节所展示的句法树形式为短语结构文法的一种上下文无关文法。这类句法树侧重于句子的语法结构，是短语结构文法研究句子结构的标准形式。

句法树，以及由句法树构成的树库是机器自动学习自然语言句法知识的重要资源。因此，句法树标注方式的好坏直接影响自动学习的效率和实现。需要指出的是，由于句法解析的精度还未达到所需的要求，而句法树又是从句子形式到句子语义识别的一个至关重要的环节，因此句法树的最终标注形式还未统一。本书提供了如下两种最常用的句法树形式：短语结构文法和依存句法。

计算语言学研究句法树的最终目的是为了使机器能够正确、全面地理解和表达句义，从而转换为知识库所需的数据结构，达到存储知识、实现推理的目标。即便句法解析的精度达到工业级的要求，也需要一个从句法树直接转换为知识库所需的RDF的阶段。由于两种数据结构的差异性，目前转换工作仍旧处于实验阶段。

### 6.1.3 汉语句类

本文将汉语句子分为简单句、复合句和复句三种类型。

（1）简单句：全句只有一个主谓结构。在标签上，除根节点是IP，其他各层的所有节点中都没有IP层。但不包括“把”字句、“被”字句、连动句等特殊句式。下面以句法树的形式，给出几个简单句示例。

① 一般主谓结构（见图6.2）。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784684221-22d0a7ea-b339-43ab-8608-8587129932c1.jpeg)

图6.2 一般主谓结构

​        ( (IP-HLN (NP-SBJ (NP-PN (NR 上海)

​                      (NR 浦东))

​                  (NP (NN 开发)

​                      (CC 与)

​                      (NN 法制)

​                      (NN 建设)))

​              (VP (VV 同步))) )

② “把”字结构（见图6.3）。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784684721-2cd80ea4-89d2-490f-8bd9-facb0f09c97e.jpeg)

图6.3 “把”字结构

​        (ROOT  (IP  (NP (PN 你))

​            (VP

​              (ADVP (AD 简直))

​              (VP (BA 把)

​              (IP

​                (NP (PN 我))

​                (VP (VV 吓死) (AS 了)))))

​            (PU 。)))

③ “被”字结构（见图6.4）。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784685227-7fc3b450-d9b2-4adf-a79a-2cd189b8e448.jpeg)

图6.4 “被”字结构

​    (ROOT  (IP

​        (NP (NR 小鸟))

​        (VP (LB 被)

​          (IP

​          (NP (PN 他们))

​          (VP (VV 吓跑) (AS 了))))

​        (PU 。)))

④ 致使结构（见图6.5）。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784685748-cc7e9250-68f6-402f-84ef-24ab0118273c.jpeg)

图6.5 致使结构

​    (ROOT  (IP

​        (NP (NN 台风))

​        (VP (VV 使)

​          (IP

​          (NP

​            (DP (DT 所有))

​            (NP (NN 房子)))

​          (VP

​                (ADVP (AD 都))

​                (VP (VV 毁) (AS 了)))))

​          (PU 。)))

（2）复合句：在一个单句或复杂句的某个单句子结构中，在某类组块的内部出现CP/IP形式的成分，或某个组块本身就是由CP/IP构成。

① 介词短语（PP）内部的小句（见图6.6）。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784686202-212a0c31-2a7e-45cb-842d-b95b3137d880.jpeg)

图6.6 介词短语（PP）内部的小句

​        ( (IP (NP-SBJ (NN 外商)  (NN 投资)  (NN 企业))  (VP (PP-TMP (P 在)  (LCP (IP (NP-SBJ

​    (-NONE- ＊PRO＊))  (VP (VV 改善)   (NP-OBJ (NP-PN (NR 中国))  (NP (NN 出口)  (NN 商品)

​    (NN 结构)))))  (LC 中)))  (VP (VV 发挥)  (AS 了)  (NP-OBJ (ADJP (JJ 显著))  (NP (NN 作

​    用)))))  (PU 。)) )

② 名词短语（NP）内部的小句（见图6.7）。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784686715-819385da-0235-4d0f-95cd-557f8f2cf018.jpeg)

图6.7 名词短语（NP）内部的小句

​            (ROOT  (IP  (NP  (CP   (IP  (NP (PN 他))   (VP (VV 考上)   (NP (NN 大学))))

​    (DEC 的))     (NP(NN 事情)))    (VP   (PP(P 在)    (NP(NN 乡里)))   (VP(VV 引起)   (VP

​    (ADVP (AD 一片))         (VP (VV 轰动)))))    (PU 。)))

③ 小句直接作为名词性短语（见图6.8）。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784687550-b6218da3-6c8e-4b11-b4d0-51041838592b.jpeg)

图6.8 小句直接作为名词性短语

​      (ROOT  (IP (NP  (CP  (IP    (NP (PN 他))   (VP (VV 说)))  (DEC 的)))    (VP  (ADVP

  (AD 都))  (VP (VV 不对。)))))

④ 紧缩句：连动结构。

❑ 连动结构（见图6.9）。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784688345-035d31ed-1bd5-4ce5-bd1a-db50b9b0ae0a.jpeg)

图6.9 连动结构

​    (ROOT  (IP

​        (NP (PN 他))

​        (VP

​          (VP (VV 上街)

​          (VP (VV 买)

​            (NP (NN 书))))

​          (VP (VV 去) (AS 了)))

​        (PU 。)))

❑ 主语脱落的情况（见图6.10）。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784688886-3ca2cc25-4de7-4829-9481-c9ef8f076ab1.jpeg)

图6.10 主语脱落的情况

​    (ROOT  (IP

​        (NP

​          (NP (PN 他们))

​          (NP (NN 手)))

​        (VP

​          (VP (VV 拉) (AS 着)

​          (NP (NN 手)))

​          (PU , )

​          (VP (VV 穿过)

​          (NP (NN 树林)))

​          (PU , )

​          (VP (VV 翻过)

​          (NP (NN 山坡)))

​          (PU , )

​          (VP (VV 回到)

​          (NP (NN 草房))))

​        (PU 。)))

（3）复句：全局有多个主谓结构，是由多个简单句和简单复合单句构成的句群。

复句例句（见图6.11）。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784689334-e75119db-6994-4d9f-84da-ebe8a78289f0.jpeg)

图6.11 复句例句

​        ((IP(IP(NP-SBJ(NN 建筑)  (NN 公司))  (VP(VV 进)   (NP-OBJ(NN 区))))(PU , )  (IP

​    (NP-SBJ (ADJP (JJ 有关))  (NP (NN 部门)))  (VP (ADVP (AD 先))    (VP (VV 送上)  (NP-OBJ

​    (DP(DT 这些))      (NP(NN 法规性)  (NN 文件))))))   (PU , )   (IP(NP-SBJ(-NONE-＊pro＊))

​    (VP (ADVP (AD 然后))        (VP (VE 有)  (IP-OBJ (NP-SBJ (ADJP (JJ 专门))  (NP (NN 队

​    伍)))   (VP (VV 进行)    (NP-OBJ (NN 监督)    (NN 检查)))))))  (PU 。)) )

从句法解析的角度看，复句由最少两个单句构成，复句中常有大量的省略成分，一般用空范畴（*pro*）标注出来。有关空范畴的详细说明请参照下文。

### 6.1.4 谓词论元与空范畴

配价理论认为在一个句子中，动词处于中心地位，动词的支配成分相当于传统语法的主语、直接宾语和间接宾语。配价中的价就是指动词对句子中名词性成分的支配数量，也称为论元数量，不同支配数量的动词有不同的论元（有关论元详细说明，参见第9章的相关解释）。一般来讲，一个动词的核心论元数量都是固定的，也就是说谓语的核心论元在句子中必须是固定的，而且凸显出来。但在实际的句子中，因为移位、隐含和省略等因素，动词的论元常常不能完整地凸显出来。

这种情况称为论元脱落情况。对于移位、隐含和省略几种不同论元脱落或移位的情况，在最初的转换生成语法中定义了如下三种不同的空范畴。

❑ 由于移位造成的空范畴。

例句：那个西红柿，我扔了。

上述例句中“西红柿”被移动到了“扔”之前。该句恢复移位后为：

我扔了那个西红柿。

为了说明，转换生成语法使用Trace或T填充句子中被移位的空位置，j表示移

位词汇的位置。使用移位空范畴进行标注的结果为：

那个西红柿(j)，我扔了T(j)。

❑ 由于隐含造成的空范畴。

例句：张三打算游泳。

上述例句中“游泳”的主语与整句的主语“张三”重复，在同一句子中为了避免重复，后面的动作的主语做了隐含。但这种隐含是可以被显示恢复的。原句恢复为：

张三打算（张三）游泳。

为了说明，转换生成语法使用PRO标签填充句子中隐含的空位置，j表示显性词汇的位置。使用隐含空范畴进行标注的结果为：

张三(j)打算PRO(j)游泳。

❑ 由于省略造成的空范畴。

例句：张三买了三斤苹果，给了他弟弟三个。

上述例句中，从句“给”的主语与主句的主语“张三”重复，为了避免重复，从句部分做了省略。这种省略也是可以被显示恢复的。原句恢复为：

张三买了三斤苹果，（张三）给了他弟弟三个。

为了说明，转换生成语法使用pro标签填充从句中省略的空位置，j表示显性词汇的位置。使用省略空范畴进行标注的结果为：

张三(j)买了三斤苹果，pro(j)给了他弟弟三个。

表6.1所示为宾州树库的所有空范畴标注及其含义，并且给出了空范畴的可替换性等特征。

表6.1 宾州树库的所有空范畴标注及其含义

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784689929-1de642db-e405-4da3-b15f-63642004c500.jpeg)

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784690470-7e6d32af-96f7-4fa6-a46b-d0069bf1bd1a.jpeg)

注意，否*：在主语控制或宾语控制的情况下，*PRO*的先行词必须处于同一个句子中。但还有第三种控制称为任意控制。在任意控制中，*PRO*的先行词可以是任意成分，不必出现在同一个句子中。

在短语结构中空范畴的表示如表6.2所示。

表6.2 在短语结构中空范畴的表示

| (XP (-NONE-*T*))    | XP的移位语迹，诸如话题化（Topicalization） |
| ------------------- | ------------------------------------------ |
| (NP (-NONE-*))      | NP的移位语迹                               |
| (NP (-NONE-*PRO*))  | 隐含主语NP的                               |
| (NP (-NONE-*pro*))  | 脱落论元（省略，主语/宾语）                |
| ((-NONE-*OP*))      | 用于关系结构的空OP算子                     |
| (WHPP (-NONE-*OP*)) | 用于特殊疑问句的空PP算子                   |
| (XP (-NONE-*RNR*))  | 用于右侧节点提升的空语类                   |
| (XP (-NONE-*?*))    | 省略占位符                                 |

（1）（-NONE-*T*）:A’移位语迹——话题化（见图6.12）。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784691076-1dad4398-828b-4e46-9df9-3c401f3c288a.jpeg)

图6.12 A’移位语迹——话题化

​        (IP (PU “)

​            (IP-TPC-1 (NP-SBJ (PN 我们))

​                      (IP (VP (VV 会)

​                            (VP (VV 赢)))

​                        (SP 的)))

​            (PU , )

​            (PU ”)

​            (NP-PN-SBJ (NR 张三))

​            (VP (VV 说)

​                (IP-OBJ (-NONE- ＊T＊-1)))

​            (PU 。))

（2）（-NONE-*T*）：关系从句中的移位（见图6.13）。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784691594-170c9854-179c-4e55-a11f-c01f50e435ad.jpeg)

图6.13 关系从句中的移位

​    (NP (CP (WHNP-1 (-NONE- ＊OP＊))

​            (CP (IP (NP-PN-SBJ (NR 日本))

​                    (VP (VV 发射)

​                        (NP-OBJ (-NONE- ＊T＊-1))))

​                (DEC 的)))

​        (ADJP (JJ 大型))

​        (NP (NN 科学)

​            (NN 实验)

​            (NN 卫星)))

（3）(-NONE-*):A-移位的语迹（见图6.14）。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784692060-40b682fa-e63a-41db-bbe0-0ff31dec4cdd.jpeg)

图6.14 A-移位的语迹

​    (IP (NP-PN-SBJ-1 (NR 张三))

​            (VP (VV 好像)

​                (IP (NP-SBJ-2 (-NONE- ＊-1))

​                  (VP (SB 被)

​                      (VP (VV 打)

​                          (AS 了)

​                          (NP-OBJ (-NONE- ＊-2)))))))

（4）(-NONE-*PRO*)：在控制结构中的空成分（见图6.15）。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784692547-dda22dea-4093-4823-971b-8a1100243deb.jpeg)

图6.15 空成分

​    (IP (NP-PN-SBJ (NR 张三))

​    (VP (VV 劝)

​          (NP-PN-OBJ (NR 李四))

​          (IP-OBJ (NP-SBJ (-NONE- ＊PRO＊))

​                  (VP (VV 参加)

​                    (NP-OBJ (NN 会见))))))

（5）(-NONE-*pro*)：用于主语脱落（pro-drop）情况中（见图6.16）。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784693594-018fcd23-c12f-45bd-997b-e8709661fc9e.jpeg)

图6.16 主语脱落

​    (IP (NP-SBJ (-NONE- ＊pro＊))

​        (VP (VV 关上)

​          (NP-OBJ (NN 门)))

​      (PU ! ))

（6）(-NONE-*RNR*)：用于右侧节点提升（见图6.17）。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/21473765/1631784694225-a24a471a-a9ea-4068-bbd8-a1f08637b741.jpeg)

图6.17 右侧节点提升

​    (VP (VP (ADVP (AD 积极))

​            (VP (VV 引进)

​              (NP-OBJ (-NONE- ＊RNR＊-1))))

​            (PU , )

​        (VP (ADVP (AD 精心))

​            (V (VV 种养)

​                  (NP-OBJ-1 (ADJP (JJ 优稀))

​                          (ADJP (JJ 名贵))

​                          (NP (NN 品种))))))

### 6.1.5 轻动词分析理论

轻动词（Light Verbs）最初是在1988年由Grimshaw和Mester提出来的，他们认为在某些语言中存在一类特殊的动词——“轻动词”，其在结构中所起的语义作用非常有限，主要扮演功能上的辅助角色。20世纪90年代中期，轻动词假设被乔姆斯基吸收，他把轻动词视为及物性谓语的核心。同时，轻动词假设和空语类相结合，轻动词的语义空灵，甚至可以没有语音形式。乔姆斯基扩大了轻动词的外延。

本章所说的“轻动词”，不完全与乔姆斯基的概念相同，它更强调了在句法中的功能语义，即“支撑”动词的概念。某些实义动词在某种特定的情况下，可以作为轻动词使用。这些轻动词全部或部分地失去了原有词汇的语义内容，作为述语句法功能的填充词，支撑其后的名词化谓词。作为支撑动词，轻动词必须与其后的名词化谓词共享至少一个核心论元。名词化谓词限制了支撑动词的语义论元。

当一个动词可同时用于轻动词和非轻动词时，需要确定轻动词的语义。轻动词的论元结构和非轻动词（Non-Light Verb）是不同的。在轻动词结构，真正的谓语通常是轻动词支持的名词化的谓词结构。

例1：他 经常 被邀请 到世界 著名 学府 作 讲演。

例2：企业 每逢 收购合并，必然 会 请 投资银行 作 顾问。

在例1中，“作”是一个支持名词化谓语“演讲”的轻动词，而它本身没有什么意义，并且没有自己的论元结构。“作”也可以用来作为非轻动词，如例2，它的意义是“充当”，并且具有两个语义论元，“投资银行”和“顾问”。

### 6.1.6 NLTK操作句法树

前文已经用NLTK输出和显示过句法树了，有关更多的操作可以在NLTK的HOWTO目录页面（http://www.nltk.org/howto/）的标题tree HOWTO下找到。但在实际操作中，有些常用的操作在HOWTO中并没有给出，本节将在此基础之上给出NLTK对句法树的一些更复杂、更常用的操作。读者要想掌握本节的代码，需要对HOWTO有一个初步的了解。

（1）得到所有的叶子节点和词性。

函数：对于本节列出的所有函数读者都可以放到treelib.py文件下。

​        def flatten_childtrees(trees): # 扁平化子树结构

​            children = []

​            for t in trees:

​                if t.height() < 3:

​                      children.extend(t.pos())

​                elif t.height() == 3:

​                      children.append(Tree(t.label(), t.pos()))

​                else:

​                      children.extend(flatten_childtrees([c for c in t]))

​            return children

​        def flatten_deeptree(tree): # 解析prop

​            return Tree(tree.label(), flatten_childtrees([c for c in tree]))

​        def getwordposlist(tree):

​            return [ tree[pos]+"/"+tree[pos[:-1]].label() for pos in tree.treepositions

​    ('leaves')]

执行代码如下。

​        \# -＊- coding: utf-8 -＊-

​        import sys, os

​        from treelib import ＊

​        reload(sys)  # 设置 UTF-8输出环境

​        sys.setdefaultencoding('utf-8')

​      mytree = Tree.fromstring(u"(IP (IP (NP-SBJ (NN 建筑)  (NN 公司))  (VP (VV 进)

  (NP-OBJ (NN 区)))) (PU , )  (IP (NP-SBJ (ADJP (JJ 有关))  (NP (NN 部门)))  (VP (ADVP (AD

  先))     (VP (VV 送上)  (NP-OBJ (DP (DT 这些))       (NP (NN 法规性)  (NN 文件))))))

  (PU , )   (IP(NP-SBJ(-NONE-＊pro＊))   (VP(ADVP(AD 然后))        (VP(VE 有)  (IP-OBJ

  (NP-SBJ (ADJP (JJ 专门))  (NP (NN 队伍)))   (VP (VV 进行)    (NP-OBJ (NN 监督)    (NN 检

  查)))))))  (PU 。))  ")

​      wordpostaglist=[word_pos[0][0]+"/"+word_pos[0][1]  for  word_pos  in  flatten_

  deeptree(mytree).pos()]

​      for wordpostag in wordpostaglist:

​          if wordpostag.find("-NONE-")==-1: #去除空范畴

​              print wordpostag,

​      print

​      for wordpostag in getwordposlist(mytree):

​          if wordpostag.find("-NONE-")==-1: #去除空范畴

​              print wordpostag,

输出结果如下。

​    建筑/NN 公司/NN 进/VV 区/NN , /PU 有关/JJ 部门/NN 先/AD 送上/VV 这些/DT 法规性/NN 文件

/NN , /PU 然后/AD 有/VE 专门/JJ 队伍/NN 进行/VV 监督/NN 检查/NN 。/PU

​    建筑/NN 公司/NN 进/VV 区/NN , /PU 有关/JJ 部门/NN 先/AD 送上/VV 这些/DT 法规性/NN 文件

/NN , /PU 然后/AD 有/VE 专门/JJ 队伍/NN 进行/VV 监督/NN 检查/NN 。/PU

（2）根据给定的词汇和子树标签，得到词汇所在的一棵子树。

​    def getbranch(tree, keyword, branchlabel):

​        gspos = tuple()

​        for pos in tree.treepositions('leaves'):

​            if tree[pos]==keyword: gspos = pos

​        indx = -1

​        for count in xrange(len(gspos)-1):

​            if tree[gspos[:indx]].label()==branchlabel:

​                  return tree[gspos[:indx]]

​            indx -= 1

执行代码如下。

​    \# -＊- coding: utf-8 -＊-

​    import sys, os

​    import re

​    from treelib import ＊

​    reload(sys)  # 设置 UTF-8输出环境

​    sys.setdefaultencoding('utf-8')

​    mytree = Tree.fromstring(u"(IP (IP (NP-SBJ (NN 建筑)  (NN 公司))  (VP (VV 进)

​    (NP-OBJ (NN 区)))) (PU , )  (IP (NP-SBJ (ADJP (JJ 有关))  (NP (NN 部门)))  (VP (ADVP (AD

​    先))     (VP (VV 送上)  (NP-OBJ (DP (DT 这些))       (NP (NN 法规性)  (NN 文件))))))

​    (PU , )   (IP(NP-SBJ(-NONE-＊pro＊))   (VP(ADVP(AD 然后))        (VP(VE 有)  (IP-OBJ

​    (NP-SBJ (ADJP (JJ 专门))  (NP (NN 队伍)))   (VP (VV 进行)    (NP-OBJ (NN 监督)    (NN 检

​    查)))))))  (PU 。))  ")

​        \# 找到"公司"所在的IP子树

​        branch = getbranch(mytree, "公司", "IP")

​        print str(branch).decode("unicode-escape")

输出结果如下。

​      (IP (NP-SBJ (NN 建筑) (NN 公司)) (VP (VV 进) (NP-OBJ (NN 区))))

（3）使用ParentTree过滤出所需要的子树（消除递归嵌套）。

​      \# -＊- coding: utf-8 -＊-

​      import sys, os

​      import re

​      from treelib import ＊

​      reload(sys)  # 设置 UTF-8输出环境

​      sys.setdefaultencoding('utf-8')

​      mytree = Tree.fromstring(u"(IP (IP (NP-SBJ (NN 建筑)  (NN 公司))  (VP (VV 进)

  (NP-OBJ (NN 区)))) (PU , )  (IP (NP-SBJ (ADJP (JJ 有关))  (NP (NN 部门)))  (VP (ADVP (AD

  先))     (VP (VV 送上)  (NP-OBJ (DP (DT 这些))       (NP (NN 法规性)  (NN 文件))))))

  (PU , )   (IP(NP-SBJ(-NONE-＊pro＊))   (VP(ADVP(AD 然后))        (VP(VE 有)  (IP-OBJ

  (NP-SBJ (ADJP (JJ 专门))  (NP (NN 队伍)))   (VP (VV 进行)    (NP-OBJ (NN 监督)    (NN 检

  查)))))))  (PU 。))  ")

​      ptree = ParentedTree.convert(mytree)

​      \# 过滤出所有的NP短语（最高层的NP，消除子节点也是NP的情况）

​      for subptree in ptree.subtrees(): # 递归遍历所有子树

​          if subptree.label().find("NP")! =-1 and mytree[subptree.treeposition()[:-1]].

  label().find("NP")==-1:

​                print str(subptree).decode("unicode-escape")

输出结果如下。

​      (NP-SBJ (NN 建筑) (NN 公司))

​      (NP-OBJ (NN 区))

​      (NP-SBJ (ADJP (JJ 有关)) (NP (NN 部门)))

​      (NP-OBJ (DP (DT 这些)) (NP (NN 法规性) (NN 文件)))

​      (NP-SBJ (-NONE- ＊pro＊))

​      (NP-SBJ (ADJP (JJ 专门)) (NP (NN 队伍)))

​      (NP-OBJ (NN 监督) (NN 检查))
